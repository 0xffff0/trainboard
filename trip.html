<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="title">Zuginformationen</title>
    <link rel="stylesheet" href="./assets/css/styles.css">
    <link rel="stylesheet" href="./assets/css/dark-styles.css">
    <link rel="stylesheet" href="./assets/css/line-colors.css">
    <link rel="shortcut icon" type="image/x-icon" href="./assets/branding/favicon.ico">
    <link rel="manifest" href="/manifest.json" type="application/json">
    <meta name="theme-color" content="#000">
    <meta name="robots" content="noindex">

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>
</head>

<body>

<center>
    <noscript> You need to enable JavaScript to run this app.</noscript>

    <nav id="navbar">
        <div class="tabs"><span class="active">&nbsp;Zuginformationen&nbsp;</span></div>
        <div class="iconbar bigonly"><a href="#" onclick="history.go(-1)">Schließen</a></div>
        <div class="iconbar"><a href="#" onclick="history.go(-1)"><img src="./assets/icons/close.svg"
                                                                       class="mediumicon"></a></div>
        <div class="iconbar"><img id="openMapBtn" class="trip-card-icon" src="./assets/icons/train-map.png" alt="Card Icon"></div>
    </nav>

    <br>

    <div class="trip-container-centered">
        <!-- Header der Seite mit Zugdetails -->
        <div class="trip-header">
            <div class="trip-title">
                <h1 id="trainTitle">Zugnummer</h1>
                <span class="trip-date" id="trip-date">Tag </span>
            </div>
            <div class="trip-duration-info">
                <img class="trip-logo" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Logo_%C3%96BB.svg/2560px-Logo_%C3%96BB.svg.png" alt="ÖBB Logo">
                <span class="trip-duration" id="tripDuration">Dauer</span>
            </div>
        </div>
        <div class="trip-status-container">
            <div class="trip-status" id="tripStatus">Status</div>
        </div>
        <div class="trip-progress-bar">
            <div class="trip-station-info">
                <div class="trip-origin-info">
                    <span id="originStation">Origin Station</span>
                </div>
                <div class="trip-destination-info">
                    <span id="destinationStation">Destination Station</span>
                </div>
            </div>
            <div class="trip-progress-bar-container">
                <div class="trip-progress"></div>
            </div>
            <div class="trip-time-info">
                <div class="trip-origin-time">
                    <span id="originTime">00:00</span>
                </div>
                <div class="trip-destination-time">
                    <span id="destinationTime">00:00</span>
                </div>
            </div>
        </div>

        <!-- Modal -->
        <div id="mapModal" style="display: none;">
            <div class="modal-content">
                <span class="close">&times;</span>
                <div id="map"></div>
            </div>
        </div>

        <script>
            document.addEventListener('DOMContentLoaded', function() {
                const modal = document.getElementById("mapModal");
                const btn = document.getElementById("openMapBtn");
                const closeBtn = document.getElementsByClassName("close")[0];
                let map;
                let marker;
                let intervalId;

                // Funktion, um Parameter aus der URL zu extrahieren
                function getParameterByName(name, url = window.location.href) {
                    name = name.replace(/[\[\]]/g, '\\$&');
                    const regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
                    const results = regex.exec(url);
                    if (!results) return null;
                    if (!results[2]) return '';
                    return decodeURIComponent(results[2].replace(/\+/g, ' '));
                }

                // Event-Handler für das Öffnen und Schließen des Modals
                btn.onclick = function() {
                    modal.style.display = "block";
                    setTimeout(() => {
                        if (!map) {
                            initMap();
                        } else {
                            map.resize(); // Wichtig, damit die Karte die richtige Größe annimmt
                        }
                    }, 300);
                }

                closeBtn.onclick = function() {
                    modal.style.display = "none";
                    clearInterval(intervalId); // Stoppe die regelmäßige Positionsabfrage, wenn das Modal geschlossen wird
                }

                window.onclick = function(event) {
                    if (event.target == modal) {
                        modal.style.display = "none";
                        clearInterval(intervalId); // Stoppe die regelmäßige Positionsabfrage, wenn das Modal geschlossen wird
                    }
                }

                // Funktion zur Aktualisierung der aktuellen Position auf der Karte
                async function updateCurrentPosition(tripId, profile) {
                    let tripApiUrl = `https://data.cuzimmartin.dev/${profile === 'oebb' ? 'oebb-trip' : 'trip'}?tripId=${encodeURIComponent(tripId)}`;
                    let tripResponse;

                    try {
                        tripResponse = await fetch(tripApiUrl);
                        if (!tripResponse.ok) {
                            throw new Error('Request failed');
                        }
                    } catch (error) {
                        // Falls die Anfrage fehlschlägt, auf die alternative API umstellen
                        const fallbackProfile = profile === 'oebb' ? 'db' : 'oebb';
                        tripApiUrl = `https://data.cuzimmartin.dev/${fallbackProfile === 'oebb' ? 'oebb-trip' : 'trip'}?tripId=${encodeURIComponent(tripId)}`;
                        tripResponse = await fetch(tripApiUrl);
                    }

                    const tripData = await tripResponse.json();

                    if (tripData.trip.currentLocation && marker) {
                        const newPosition = [tripData.trip.currentLocation.longitude, tripData.trip.currentLocation.latitude];
                        marker.setLngLat(newPosition);
                    }
                }

                async function initMap() {
                    const tripId = getParameterByName('tripId');
                    let profile = getParameterByName('profile') || 'oebb'; // Standardprofil ist 'oebb'

                    if (!tripId) {
                        alert("Keine tripId in der URL gefunden.");
                        return;
                    }

                    let polylineApiUrl = `https://data.cuzimmartin.dev/trip/${encodeURIComponent(tripId)}/polyline?profile=${profile}`;
                    let polylineResponse;

                    try {
                        polylineResponse = await fetch(polylineApiUrl);
                        if (!polylineResponse.ok) {
                            throw new Error('Polyline request failed');
                        }
                    } catch (error) {
                        // Falls die Anfrage fehlschlägt, auf die alternative API umstellen
                        const fallbackProfile = profile === 'oebb' ? 'db' : 'oebb';
                        profile = fallbackProfile;
                        polylineApiUrl = `https://data.cuzimmartin.dev/trip/${encodeURIComponent(tripId)}/polyline?profile=${profile}`;
                        polylineResponse = await fetch(polylineApiUrl);
                    }

                    const polylineData = await polylineResponse.json();

                    let tripApiUrl = `https://data.cuzimmartin.dev/${profile === 'oebb' ? 'oebb-trip' : 'trip'}?tripId=${encodeURIComponent(tripId)}`;
                    let tripResponse;

                    try {
                        tripResponse = await fetch(tripApiUrl);
                        if (!tripResponse.ok) {
                            throw new Error('Trip request failed');
                        }
                    } catch (error) {
                        // Falls die Anfrage fehlschlägt, auf die alternative API umstellen
                        const fallbackProfile = profile === 'oebb' ? 'db' : 'oebb';
                        tripApiUrl = `https://data.cuzimmartin.dev/${fallbackProfile === 'oebb' ? 'oebb-trip' : 'trip'}?tripId=${encodeURIComponent(tripId)}`;
                        tripResponse = await fetch(tripApiUrl);
                    }

                    const tripData = await tripResponse.json();

                    // Bestimmen der Startposition aus den Polyline-Daten
                    let startPosition = [16.3738, 48.2082]; // Standardposition
                    if (polylineData.polyline && polylineData.polyline.features && polylineData.polyline.features.length > 0) {
                        const firstFeature = polylineData.polyline.features[0];
                        if (firstFeature.geometry.type === "Point") {
                            startPosition = [firstFeature.geometry.coordinates[0], firstFeature.geometry.coordinates[1]];
                        }
                    }

                    mapboxgl.accessToken = 'pk.eyJ1IjoibWFydGlpbmhpZXIiLCJhIjoiY2x6b284ZGxtMHRlbzJpcjd5em80MDIxcSJ9.BMb9-B_QvsdFy6arQxennw';
                    map = new mapboxgl.Map({
                        container: 'map',
                        style: 'mapbox://styles/mapbox/dark-v10',
                        center: startPosition,
                        zoom: 10
                    });

                    if (polylineData.polyline && polylineData.polyline.features) {
                        const coordinates = polylineData.polyline.features.map(feature => {
                            if (feature.geometry.type === "Point") {
                                return [feature.geometry.coordinates[0], feature.geometry.coordinates[1]];
                            }
                        }).filter(coord => coord);

                        const fullRoute = {
                            'type': 'Feature',
                            'geometry': {
                                'type': 'LineString',
                                'coordinates': coordinates
                            }
                        };

                        map.on('load', () => {
                            map.addSource('fullRoute', {
                                'type': 'geojson',
                                'data': fullRoute
                            });

                            map.addLayer({
                                'id': 'fullRoute',
                                'type': 'line',
                                'source': 'fullRoute',
                                'layout': {
                                    'line-join': 'round',
                                    'line-cap': 'round'
                                },
                                'paint': {
                                    'line-color': '#1db7dd',
                                    'line-width': 4
                                }
                            });

                            if (tripData.trip.currentLocation) {
                                const currentLocation = [tripData.trip.currentLocation.longitude, tripData.trip.currentLocation.latitude];
                                marker = new mapboxgl.Marker({ color: "red" })
                                    .setLngLat(currentLocation)
                                    .addTo(map);
                            } else {
                                console.warn("Aktuelle Position nicht verfügbar, Marker wird nicht gesetzt.");
                            }

                            const bounds = coordinates.reduce(function(bounds, coord) {
                                return bounds.extend(coord);
                            }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));

                            map.fitBounds(bounds, {
                                padding: { top: 50, bottom: 50, left: 50, right: 50 }
                            });

                            if (tripData.trip.currentLocation) {
                                intervalId = setInterval(() => updateCurrentPosition(tripId, profile), 10000);
                            }
                        });
                    } else {
                        console.error("Keine gültigen Polyline-Daten gefunden");
                    }
                }
            });

        </script>


        <!-- Liste der Haltestellen -->
        <div class="trip-stopovers">
            <!-- Dynamisch generierte Stopover-Elemente werden hier eingefügt -->
        </div>

        <!-- Warnungen und Hinweise -->
        <div class="trip-warnings">
            <ul id="warningsList">
                <!-- Dynamisch generierte Warnungen werden hier eingefügt -->
            </ul>
        </div>
    </div>




    <br><br><br>

</center>

<script>
    async function fetchAndDisplayData() {
        const currentUrl = window.location.href;

        function getParameterByName(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, '\\$&');
            const regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
            const results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, ' '));
        }

        const tripId = getParameterByName('tripId', currentUrl);
        let profile = getParameterByName('profile', currentUrl) || 'oebb'; // Standardprofil ist 'oebb'

        let data;
        let primaryEndpoint = profile === 'oebb' ? 'oebb-trip' : 'trip';
        let fallbackProfile = profile === 'oebb' ? 'db' : 'oebb';
        let fallbackEndpoint = fallbackProfile === 'oebb' ? 'oebb-trip' : 'trip';

        try {
            const apiUrl = `https://data.cuzimmartin.dev/${primaryEndpoint}?tripId=${encodeURIComponent(tripId)}`;
            const response = await fetch(apiUrl);
            if (!response.ok) {
                throw new Error(`Fehler beim Abrufen der Daten von ${primaryEndpoint}: ${response.statusText}`);
            }
            data = await response.json();

            if (!data.trip) {
                throw new Error('Keine Daten für diese Reise gefunden.');
            }
        } catch (error) {
            console.warn(`Problem mit der ${primaryEndpoint} API, wechsle zur ${fallbackEndpoint} API.`, error);
            try {
                const apiUrl = `https://data.cuzimmartin.dev/${fallbackEndpoint}?tripId=${encodeURIComponent(tripId)}`;
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error(`Fehler bei der Fallback API (${fallbackEndpoint}): ${response.statusText}`);
                }
                data = await response.json();
                profile = fallbackProfile; // Setze das Profil auf das Fallback-Profil
            } catch (secondError) {
                console.error('Fehler auch bei der Fallback API:', secondError);
                const statusElement = document.getElementById('tripStatus');
                statusElement.textContent = `Fehler beim Abrufen der Zugdaten über beide APIs.`;
                return;
            }
        }

        // Titel und Details setzen
        document.getElementById('trainTitle').textContent = `${data.trip.line.productName} ${data.trip.line.fahrtNr}`;
        document.getElementById('title').textContent = `Zuginformationen zu ${data.trip.line.productName} ${data.trip.line.fahrtNr}`;

        // Dauer berechnen
        const departureTime = new Date(data.trip.plannedDeparture);
        const arrivalTime = new Date(data.trip.plannedArrival);
        const duration = (arrivalTime - departureTime) / (1000 * 60 * 60); // Stunden
        const minutes = Math.floor((duration % 1) * 60);
        document.getElementById('tripDuration').textContent = `${Math.floor(duration)}:${minutes.toString().padStart(2, '0')} Std`;

        // Datum setzen
        const tripDate = departureTime.toLocaleDateString('de-DE', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
        document.getElementById('trip-date').innerHTML = tripDate;

        // Ursprungsstation und Zielstation setzen
        document.getElementById('originStation').textContent = data.trip.origin.name;
        document.getElementById('originTime').textContent = departureTime.toLocaleTimeString('de-DE', {
            hour: '2-digit',
            minute: '2-digit'
        });
        document.getElementById('destinationStation').textContent = data.trip.destination.name;
        document.getElementById('destinationTime').textContent = arrivalTime.toLocaleTimeString('de-DE', {
            hour: '2-digit',
            minute: '2-digit'
        });

        // Dynamische Fortschrittsleiste aktualisieren
        setProgressBar(departureTime, new Date(), arrivalTime);

        // Haltestellen dynamisch hinzufügen
        const stopoversContainer = document.querySelector('.trip-stopovers');
        stopoversContainer.innerHTML = '';
        data.trip.stopovers.forEach(stop => {
            const stopElement = document.createElement('div');
            if (stop.cancelled) {
                stopElement.classList.add('trip-stopover');
                stopElement.innerHTML = `
                <div class="trip-stop-time">
                    <div class="trip-delay" style="font-size: 16px">Halt entfällt</div>
                </div>
                <div class="trip-stop-info">
                    <span class="trip-stop-name">${stop.stop.name}</span>
                </div>
            `;
            } else {
                const plannedArrivalTime = stop.plannedArrival ? new Date(stop.plannedArrival).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const actualArrivalTime = stop.arrival ? new Date(stop.arrival).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const plannedDepartureTime = stop.plannedDeparture ? new Date(stop.plannedDeparture).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const actualDepartureTime = stop.departure ? new Date(stop.departure).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';

                const arrivalTimeDisplay = plannedArrivalTime === actualArrivalTime ? plannedArrivalTime : `<s>${plannedArrivalTime}</s> <span class="trip-delay">${actualArrivalTime}</span>`;
                const departureTimeDisplay = plannedDepartureTime === actualDepartureTime ? plannedDepartureTime : `<s>${plannedDepartureTime}</s> <span class="trip-delay">${actualDepartureTime}</span>`;

                stopElement.classList.add('trip-stopover');
                stopElement.innerHTML = `
                <div class="trip-stop-time">
                    <div>${arrivalTimeDisplay}</div>
                    <div>${departureTimeDisplay}</div>
                </div>
                <div class="trip-stop-info">
                    <span class="trip-stop-name">${stop.stop.name}</span>
                    <span class="trip-platform">${(stop.arrivalPlatform || stop.departurePlatform) ? `Gleis ${stop.arrivalPlatform || stop.departurePlatform}` : '-'}</span>
                </div>
            `;
            }
            stopoversContainer.appendChild(stopElement);
        });

        // Warnungen dynamisch hinzufügen
        const warningsList = document.getElementById('warningsList');
        warningsList.innerHTML = '';
        if (data.trip.remarks && data.trip.remarks.length > 0) {
            const warnings = data.trip.remarks.map(remark => remark.text);
            warnings.forEach(warning => {
                const warningItem = document.createElement('div');
                warningItem.classList.add('trip-warning-item');
                warningItem.textContent = warning;
                warningsList.appendChild(warningItem);
            });
        } else {
            const noWarningsItem = document.createElement('div');
            noWarningsItem.classList.add('trip-warning-item');
            noWarningsItem.textContent = 'Keine Warnungen vorhanden.';
            warningsList.appendChild(noWarningsItem);
        }

        // Dynamischen Status des Zuges setzen
        updateTrainStatus(data.trip);
    }



    function setProgressBar(departureTime, currentTime, arrivalTime) {
        const startTime = new Date(departureTime);
        const endTime = new Date(arrivalTime);

        // Gesamtzeitspanne zwischen Abfahrt und Ankunft
        const totalTime = endTime - startTime;
        // Verstrichene Zeit seit der Abfahrt
        const elapsedTime = currentTime - startTime;

        // Berechnen des Fortschritts als Prozentsatz
        let progressPercentage = (elapsedTime / totalTime) * 100;

        // Fortschritt auf 0% und 100% beschränken
        progressPercentage = Math.max(0, Math.min(progressPercentage, 100));

        // Fortschrittsleiste aktualisieren
        const progressBar = document.querySelector('.trip-progress');
        progressBar.style.width = progressPercentage + '%';
    }

    function updateTrainStatus(trip) {
        const currentTime = new Date();
        const departureTime = new Date(trip.departure);
        const arrivalTime = new Date(trip.arrival);

        const statusElement = document.getElementById('tripStatus');

        // Wenn der Zug noch nicht abgefahren ist
        if (currentTime < departureTime) {
            const timeUntilDeparture = departureTime - currentTime;
            const minutesUntilDeparture = Math.round(timeUntilDeparture / 60000);
            const hours = Math.floor(minutesUntilDeparture / 60);
            const minutes = minutesUntilDeparture % 60;

            let timeString;
            if (hours > 0) {
                timeString = `${hours} Stunde${hours > 1 ? 'n' : ''} und ${minutes} Minute${minutes !== 1 ? 'n' : ''}`;
            } else {
                timeString = `${minutes} Minute${minutes !== 1 ? 'n' : ''}`;
            }

            const platformInfo = trip.origin.departurePlatform ? `auf Gleis ${trip.origin.departurePlatform}` : '';
            statusElement.textContent = `Fährt in ${timeString} von ${trip.origin.name} ${platformInfo} ab.`;
            return;
        }

        // Wenn der Zug bereits abgefahren ist, finde den nächsten Halt
        let nextStop = null;
        for (let i = 0; i < trip.stopovers.length; i++) {
            const stop = trip.stopovers[i];
            if (new Date(stop.plannedDeparture) > currentTime) {
                nextStop = stop;
                break;
            }
        }

        if (nextStop) {
            const timeUntilNextStop = new Date(nextStop.plannedArrival) - currentTime;
            const minutesUntilNextStop = Math.round(timeUntilNextStop / 60000);

            if (minutesUntilNextStop >= 0) {
                const hours = Math.floor(minutesUntilNextStop / 60);
                const minutes = minutesUntilNextStop % 60;

                let timeString;
                if (hours > 0) {
                    timeString = `${hours} Stunde${hours > 1 ? 'n' : ''} und ${minutes} Minute${minutes !== 1 ? 'n' : ''}`;
                } else {
                    timeString = `${minutes} Minute${minutes !== 1 ? 'n' : ''}`;
                }

                const platformInfo = nextStop.arrivalPlatform || nextStop.departurePlatform ?
                    `auf Gleis ${nextStop.arrivalPlatform || nextStop.departurePlatform}` : '';

                statusElement.textContent = `Erreicht in ${timeString} die Station ${nextStop.stop.name} ${platformInfo}.`;
            } else {
                statusElement.textContent = `Zug hat die Station ${nextStop.stop.name} erreicht.`;
            }
        } else {
            // Wenn kein nächster Halt mehr bevorsteht oder kein Remark vorhanden ist
            if (currentTime > arrivalTime) {
                statusElement.textContent = `Zug hat sein Ziel ${trip.destination.name} erreicht.`;
            } else {
                statusElement.textContent = `Zug ist auf dem Weg zu ${trip.destination.name}.`;
            }
        }
    }



    document.addEventListener('DOMContentLoaded', () => {
        fetchAndDisplayData();

        // Alle 30 Sekunden die Daten aktualisieren
        setInterval(fetchAndDisplayData, 30000); // 30 Sekunden in Millisekunden
    });




    function fetchtraincomposition(zugnummer, datetime, stationId) {


        fetch(`https://ist-wr.noncd.db.de/wagenreihung/1.0/${zugnummer}/${datetime}`)
            .then(response => response.json())
            .then(data => {


                // Check for valid JSON
                if (data.error) {
                    document.getElementById('notice').innerHTML = '<br><br>Wagenreihung für diesen Zug nicht verfügbar.<br><br>';
                    document.getElementById('coacheswrapper').classList.add('hidden');
                    return;
                }
                if (data.data.istformation.halt.evanummer !== stationId) { //Check if Wagenreihung is for the right station
                    console.log("StationID does not match:", stationId, data.data.istformation);
                    document.getElementById('notice').innerHTML = '<br><br>Wagenreihung für diesen Zug nicht verfügbar.<br><br>';
                    document.getElementById('coacheswrapper').classList.add('hidden');
                    document.getElementById('git-info').className = '';
                    //Create direct link for Issue report on GitHub
                    document.getElementById('git-error').innerHTML = `<a href="https://github.com/hoolycrash/trainboard/issues/new?title=Bug%20Wagenreihung:&body=Train:${zugnummer}%20Datetime:${datetime}%20Station:${stationId}" target="_blank" class="black">Open new Issue with Train data on Github</a>`;
                    return;
                }
                document.getElementById('git-info').className = '';
                document.getElementById('git-error').innerHTML = `<a href="https://github.com/hoolycrash/trainboard/issues/new?title=Bug%20Wagenreihung:&body=Train:${zugnummer}%20Datetime:${datetime}%20Station:${stationId}" target="_blank" class="black">Open new Issue with Train data on Github</a>`;
                rendertraincomposition(data.data.istformation);
            });
    }

    function rendertraincomposition(data) {

        /* //Did not work with more then one train set
        const allFahrzeuggruppe = data.allFahrzeuggruppe;
        const firstElementsMap = new Map();
        for (let i = 0; i < allFahrzeuggruppe.length; i++) {
            let fahrzeuggruppe = allFahrzeuggruppe[i];
            for ( let j = 0; j < fahrzeuggruppe.allFahrzeug.length; j++) {
                const fahrzeug = fahrzeuggruppe.allFahrzeug[j];
                const positioningruppe = fahrzeug.positioningruppe;
                if (!firstElementsMap.has(positioningruppe)) {
                    firstElementsMap.set(positioningruppe, fahrzeug);
                } else {
                    console.log("Already set", positioningruppe, fahrzeug);
                    //const existingFahrzeuge = firstElementsMap.get(positioningruppe);
                    //existingFahrzeuge.push(fahrzeug);
                    //firstElementsMap.set(positioningruppe, existingFahrzeuge);
        }	}	}

        // Sort elements
        const sortedFahrzeuge = Array.from(firstElementsMap.values()).sort((a, b) => {
            return parseInt(a.positioningruppe) - parseInt(b.positioningruppe);
        });
        console.log(firstElementsMap);
        */

        const blocksContainer = document.getElementById('blocksContainer');
        let vehiclename = "";
        const imgpath = 'assets/icons/carriage';
        const allFahrzeuggruppe = data.allFahrzeuggruppe;
        console.log("Wagenreihung:", data);

        // several trains -> every train
        for (let i = 0; i < allFahrzeuggruppe.length; i++) {
            let fahrzeuggruppe = allFahrzeuggruppe[i];
            let setLOK = false; //Boolean TrainSet has LOK

            //
            let vehicletype;
            let getvehicleType = getVehicleType(fahrzeuggruppe.fahrzeuggruppebezeichnung);
            if (getvehicleType[2] !== "") {
                vehicletype = getvehicleType[1] + " (BR" + getvehicleType[2] + ")";
            } else {
                vehicletype = getvehicleType[1];
            }
            if (vehicletype !== "") {
                console.log(vehicletype);
            }
            vehiclename = +vehicletype;

            //one train set -> every coach ("Wagon")
            for (let j = 0; j < fahrzeuggruppe.allFahrzeug.length; j++) {
                let fahrzeug = fahrzeuggruppe.allFahrzeug[j];

                const wagenordnungsnummer = fahrzeug.wagenordnungsnummer;
                const fahrzeugnummer = 'fzg' + fahrzeug.fahrzeugnummer;
                const kategorie = fahrzeug.kategorie;
                const ausstattungsDiv = document.createElement('div');
                ausstattungsDiv.classList.add('coach');
                //Boolean for Show IMG
                let showIMG = true;

                //check TrainSET has LOK -> Add Head on Coach

                ausstattungsDiv.classList.add(fahrzeugnummer);

                if (setLOK === true) {
                    ausstattungsDiv.classList.add('head');
                    setLOK = false;
                }

                if (kategorie === "LOK") {
                    ausstattungsDiv.classList.add('lok');
                    ausstattungsDiv.innerHTML = `LOK`;
                    setLOK = true;
                    showIMG = false;
                }

                if (j === 0 && kategorie !== "LOK") {
                    if (kategorie === "TRIEBKOPF" || kategorie.includes("STEUERWAGEN")) {
                        ausstattungsDiv.classList.add('steuerHead');
                        if (kategorie === "TRIEBKOPF") {
                            showIMG = false
                        }
                    } else {
                        ausstattungsDiv.classList.add('head');
                    }
                }

                if (j === (fahrzeuggruppe.allFahrzeug.length - 1) && kategorie !== "LOK" && !(i === 0 && j === 0)) {
                    if (kategorie === "TRIEBKOPF" || kategorie.includes("STEUERWAGEN")) {
                        ausstattungsDiv.classList.add('steuerBack');
                        if (kategorie === "TRIEBKOPF") {
                            showIMG = false
                        }
                    } else {
                        ausstattungsDiv.classList.add('back');
                    }
                }

                //if next coach == LOK -> Back
                if (j === (fahrzeuggruppe.allFahrzeug.length - 2)
                    && fahrzeuggruppe.allFahrzeug[j + 1].kategorie === "LOK") {
                    ausstattungsDiv.classList.add('back');
                }

                //single Coach in Train
                if (j === 0 && (fahrzeuggruppe.allFahrzeug.length - 1) === 0) {
                    //Train-Set has only one Coach or is BR650 (RS1)
                    if (i === 0 && (allFahrzeuggruppe.length - 1) === 0 || getvehicleType[2] === "650") {
                        ausstattungsDiv.className = 'coach';
                        ausstattungsDiv.classList.add('single');
                    } else {
                        if (i > 0 && kategorie !== "LOK") {
                            ausstattungsDiv.className = 'coach';
                            //if 2th vehicle after LOK
                            if (i === 1 && allFahrzeuggruppe[0].allFahrzeug[0].kategorie === "LOK") {
                                ausstattungsDiv.classList.add('head');
                            }
                            //if last Coach befor LOK
                            if (i === (allFahrzeuggruppe.length - 2) && allFahrzeuggruppe[i + 1].allFahrzeug[0].kategorie === "LOK") {
                                ausstattungsDiv.classList.add('back');
                            }
                            // if Last Coach
                            if (i === (allFahrzeuggruppe.length - 1) && kategorie !== "LOK") {
                                if (kategorie.includes("STEUERWAGEN")) {
                                    ausstattungsDiv.classList.add('steuerBack');
                                } else {
                                    ausstattungsDiv.classList.add('back');
                                }
                            }
                        }
                    }
                }

                if (fahrzeug.status === "GESCHLOSSEN") {
                    ausstattungsDiv.innerHTML = `x`;
                    showIMG = false;
                    //ausstattungsDiv.innerHTML += `<br><br>${fahrzeug.fahrzeugsektor}`;
                }

                if (showIMG) {

                    ausstattungsDiv.innerHTML = `<div class='sector'>${fahrzeug.fahrzeugsektor}`;

                    if (kategorie !== "STEUERWAGENZWEITEKLASSE" && kategorie !== "REISEZUGWAGENZWEITEKLASSE" && kategorie !== "DOPPELSTOCKSTEUERWAGENZWEITEKLASSE" && kategorie !== "DOPPELSTOCKWAGENZWEITEKLASSE") {
                        ausstattungsDiv.innerHTML += `${wagenordnungsnummer}<br><img src="${imgpath}/${kategorie}.svg">`;
                    } else {
                        ausstattungsDiv.innerHTML += `${wagenordnungsnummer}<br>`;
                    }
                    ;

                    //let countausstatt = 0;
                    fahrzeug.allFahrzeugausstattung.forEach(ausstattung => {
                        if (
                            //countausstatt < 2 &&
                            !["KLIMA"].includes(ausstattung.ausstattungsart)) {
                            //countausstatt++;
                            ausstattungsDiv.innerHTML += `<img src="${imgpath}/${ausstattung.ausstattungsart}.svg">`;
                        }
                        //TODO: Optimize which AUSSTATTUNG are shown
                    });

                }
                blocksContainer.appendChild(ausstattungsDiv);
                //Next Coach
            }
            //Next Train
        }
    }


    function getVehicleType(fahrzeugbezeichnung) {
        let type = "";
        let series = "";
        let name = "";
        if (fahrzeugbezeichnung.startsWith("ICE")) {
            let name = fahrzeugbezeichnung.substring(0, 3);
            let number = fahrzeugbezeichnung.substring(3);
            let firstnum = number.substring(0, 2);
            let lastnum = number.substring(2);
            switch (firstnum) {
                case "01":
                    type = "ICE 1";
                    series = "401";
                    break;
                case "02":
                    type = "ICE 2";
                    series = "402";
                    break;
                case "03":
                    type = "ICE 3";
                    series = "403";
                    break;
                case "46":
                    type = "ICE 3";
                    series = "406";
                    break;
                case "47":
                    type = "ICE 3";
                    series = "407";
                    break;
                case "80":
                    type = "ICE 3";
                    series = "408";
                    break;
                case "90":
                    type = "ICE 4";
                    series = "412.0";
                    break;
                case "92":
                    type = "ICE 4";
                    series = "412.2";
                    break;
                case "94":
                    type = "ICE 4";
                    series = "412.4";
                    break;
                case "11":
                    type = "ICE T";
                    series = "411";
                    break;
                case "15":
                    type = "ICE T";
                    series = "415";
                    break;
                default:
            }
        }
        if (fahrzeugbezeichnung.startsWith("ICK")) {
            type = "IC2 KISS";
        }
        if (fahrzeugbezeichnung.startsWith("ICD")) {
            type = "IC2";
        }
        if (fahrzeugbezeichnung.startsWith("T0442")) {
            type = "Talent 2";
            series = "442";
        }
        if (fahrzeugbezeichnung.startsWith("T1442")) {
            type = "Talent 2";
            series = "1442";
        }
        if (fahrzeugbezeichnung.startsWith("D0650")) {
            type = "RS1";
            series = "650";
        }

        return [fahrzeugbezeichnung, type, series, name];
    }


    fetchAndDisplayData();

</script>

</body>
</html>