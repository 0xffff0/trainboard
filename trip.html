<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="title">Zuginformationen</title>
    <link rel="stylesheet" href="./assets/css/styles.css">
    <link rel="stylesheet" href="./assets/css/dark-styles.css">
    <link rel="stylesheet" href="./assets/css/line-colors.css">
    <link rel="shortcut icon" type="image/x-icon" href="./assets/branding/favicon.ico">
    <link rel="manifest" href="/manifest.json" type="application/json">
    <meta name="theme-color" content="#000">
    <meta name="robots" content="noindex">

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>
</head>

<body id="body">

<center>
    <noscript> You need to enable JavaScript to run this app.</noscript>

    <nav id="navbar">
        <div class="tabs"><span class="active">&nbsp;Zuginformationen&nbsp;</span></div>
        <div class="iconbar bigonly"><a href="#" onclick="history.go(-1)">Schließen</a></div>
        <div class="iconbar"><a href="#" onclick="history.go(-1)"><img src="./assets/icons/close.svg" class="mediumicon"></a></div>
    </nav>

    <div class="coloredSpace" id="bigheaderbox">
        <div class="darker">
            <br>
            <div class="blanktable">
                <div class="tripcontainer">
                    <div class="trip-header">
                        <div class="trip-title">
                            <table><tr><td style="vertical-align: middle;"><div class="whiteBadge" id="linebadge"></div></td><td style="vertical-align: middle; padding-left: 10px;"><span id="originStation"></span> - <span id="destinationStation">Destination Station</span><br><small class="disabled" id="trip-date">Tag </small><br></td></tr></table><br>
                        </div>
                    </div>
                    <div class="trip-progress-bar">
                        <div class="trip-station-info">
                            <div class="trip-origin-info">
                            </div>
                            <div class="trip-destination-info">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="coloredSpace displayflex center">
        <div class="tinybutton firstbutton">
            <img src="./assets/icons/train.svg" class="slidericon"><br>
            <span id="trainTitle">Zugnummer</span><br>
            <small class="disabled">Zugnummer</small>
        </div>



        <div class="tinybutton" id="openMapBtn">
            <img src="./assets/icons/train-map.svg" class="slidericon"><br>
            Karte<br>
            <small class="disabled">Strecke & Live-Position</small>
        </div>

        <div class="tinybutton" id="myDiv">
            <img src="./assets/icons/addtrain.png" id="addtrainIcon" class="slidericon"><br>
            <span id="pinIt">Anheften</span><br>
            <small class="disabled">Fahrt anpinnen</small>
        </div>

        <a href="https://www.bahn.de/buchung/jetzt-einchecken?dbkanal_007=tutorialSlider_14-1_link_KomfortCheckinimBrowseraufrufen">
            <div class="tinybutton hidden" id="comfortbutton">
                <img src="./assets/icons/comfortcheckin.svg" class="slidericon"><br>
                Komfort-Checkin<br>
                <small class="disabled">Jetzt einchecken</small>
            </div>
        </a>


        <a id="wagonorderbutton">
            <div class="tinybutton">
                <img src="./assets/icons/wagonorder.svg" class="slidericon"><br>
                Wagenreihung<br>
                <small>Würfelsektoren</small>
            </div>
        </a>

        <a href="#remarks">
            <div class="tinybutton yellowbutton">
                <div class="trip-warning-counter" id="trip-warning-counter-button">&nbsp;Keine&nbsp;</div>
                <span id="pinIt">aktuelle Meldung</span><br>
                <small>Hinweise zur Fahrt</small>
            </div>
        </a>


    </div>


    <div class="trip-container-centered">

        <div class="trip-status-container"></div>
        <!-- Header der Seite mit Zugdetails -->







        <!-- Modal -->

        <div class="secondary" id="tripStatus"><img src="./assets/blackSpinner.svg" class="loadingspinner multicolorspinner"></div>
    </div>
    <div id="mapModal" style="display: none;">
        <div class="modal-content">
            <nav id="navbar">
                <div class="tabs"><span class="active">&nbsp;<span id ="mapHeader"></span>&nbsp;</span></div>
                <a class="close">
                    <div class="iconbar bigonly">Schließen</div>
                    <div class="iconbar"><img src="./assets/icons/close.svg" class="mediumicon close"></div>
                </a>
            </nav>


            <div id="map"></div>
        </div>

    </div>


    <!-- Liste der Haltestellen -->
    <div class="trip-stopovers blanktext">
        <!-- Dynamisch generierte Stopover-Elemente werden hier eingefügt -->
    </div>

    <!-- Warnungen und Hinweise -->

    <div class="gray" id="remarks">
        <div class="blanktext">
            <table id="remarksTable" cellpadding="10"></table>
        </div>

        <br>
    </div>


    <br>

    <small>Datenanbieter:</small><br>
    <img class="trip-logo" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Logo_%C3%96BB.svg/2560px-Logo_%C3%96BB.svg.png" alt="ÖBB Logo" class="dataproviderLogo">



    <br><br><br>
    </div>




</center>


<script>
    // Profilzustände über Seitenaktualisierungen hinweg speichern
    let profileFailureCache = {};
    let currentTripId = null;
    let profileUsed;

    // Funktion zur Bestimmung der Profile basierend auf Zugtyp und Betreiber
    function determineProfiles(train) {
        const operatorId = train.line.operator && train.line.operator.id ? train.line.operator.id.toLowerCase() : '';
        const productName = train.line.productName ? train.line.productName.toLowerCase() : '';

        let mainProfile = 'oebb';
        let fallbackProfile = 'db';

        // Prüfen, ob der Zug eine S-Bahn oder ein Regionalzug der DB ist
        const isRegionalDBTrain = (
            (productName.includes('s') || productName.includes('re') || productName.includes('fex') || productName.includes('rb') || productName.includes('bus')) &&
            operatorId.includes('db')
        );

        if (isRegionalDBTrain) {
            mainProfile = 'db';
            fallbackProfile = 'oebb';
        }

        return {mainProfile, fallbackProfile};
    }

    // Funktion, um Parameter aus der URL zu extrahieren
    function getParameterByName(name, url = window.location.href) {
        name = name.replace(/[\[\]]/g, '\\$&');
        const regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
        const results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }

    let map;
    let marker;
    let intervalId;

    // Funktion zur Aktualisierung der aktuellen Position auf der Karte
    async function updateCurrentPosition(tripId, profile) {
        let tripApiUrl = `https://data.cuzimmartin.dev/${profile === 'oebb' ? 'oebb-trip' : 'trip'}?tripId=${encodeURIComponent(tripId)}`;
        let tripResponse;

        try {
            tripResponse = await fetch(tripApiUrl);
            if (!tripResponse.ok) {
                throw new Error('Request failed');
            }
        } catch (error) {
            // Falls die Anfrage fehlschlägt, auf die alternative API umstellen
            const fallbackProfile = profile === 'oebb' ? 'db' : 'oebb';
            tripApiUrl = `https://data.cuzimmartin.dev/${fallbackProfile === 'oebb' ? 'oebb-trip' : 'trip'}?tripId=${encodeURIComponent(tripId)}`;
            tripResponse = await fetch(tripApiUrl);
            profile = fallbackProfile;
        }

        const tripData = await tripResponse.json();

        if (tripData.trip.currentLocation && marker) {
            const newPosition = [tripData.trip.currentLocation.longitude, tripData.trip.currentLocation.latitude];
            marker.setLngLat(newPosition);
        }
    }

    // Funktion zum Initialisieren der Karte
    async function initMap(profileUsed) {
        const tripId = decodeURIComponent(getParameterByName('tripId'));
        const stationId = getParameterByName('stationID');

        if (!tripId) {
            alert("Keine tripId in der URL gefunden.");
            return;
        }

        let profile = profileUsed;

        let polylineApiUrl = `https://data.cuzimmartin.dev/trip/${encodeURIComponent(tripId)}/polyline?profile=${profile}`;
        let polylineResponse;

        try {
            polylineResponse = await fetch(polylineApiUrl);
            if (!polylineResponse.ok) {
                throw new Error('Polyline request failed');
            }
        } catch (error) {
            // Falls die Anfrage fehlschlägt, auf das alternative Profil umstellen
            const fallbackProfile = profile === 'oebb' ? 'db' : 'oebb';
            profile = fallbackProfile;
            polylineApiUrl = `https://data.cuzimmartin.dev/trip/${encodeURIComponent(tripId)}/polyline?profile=${profile}`;
            polylineResponse = await fetch(polylineApiUrl);
        }

        const polylineData = await polylineResponse.json();

        let tripApiUrl = `https://data.cuzimmartin.dev/${profile === 'oebb' ? 'oebb-trip' : 'trip'}?tripId=${encodeURIComponent(tripId)}`;
        let tripResponse;

        try {
            tripResponse = await fetch(tripApiUrl);
            if (!tripResponse.ok) {
                throw new Error('Trip request failed');
            }
        } catch (error) {
            // Falls die Anfrage fehlschlägt, auf das alternative Profil umstellen
            const fallbackProfile = profile === 'oebb' ? 'db' : 'oebb';
            profile = fallbackProfile;
            tripApiUrl = `https://data.cuzimmartin.dev/${profile === 'oebb' ? 'oebb-trip' : 'trip'}?tripId=${encodeURIComponent(tripId)}`;
            tripResponse = await fetch(tripApiUrl);
        }

        const tripData = await tripResponse.json();

        // Bestimmen der Startposition aus den Polyline-Daten
        let startPosition = [16.3738, 48.2082]; // Standardposition
        if (polylineData.polyline && polylineData.polyline.features && polylineData.polyline.features.length > 0) {
            const firstFeature = polylineData.polyline.features[0];
            if (firstFeature.geometry.type === "Point") {
                startPosition = [firstFeature.geometry.coordinates[0], firstFeature.geometry.coordinates[1]];
            }
        }

        mapboxgl.accessToken = 'pk.eyJ1IjoibWFydGlpbmhpZXIiLCJhIjoiY2x6b284ZGxtMHRlbzJpcjd5em80MDIxcSJ9.BMb9-B_QvsdFy6arQxennw';
        map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/dark-v10',
            center: startPosition,
            zoom: 10
        });

        if (polylineData.polyline && polylineData.polyline.features) {
            const coordinates = polylineData.polyline.features.map(feature => {
                if (feature.geometry.type === "Point") {
                    return [feature.geometry.coordinates[0], feature.geometry.coordinates[1]];
                }
            }).filter(coord => coord);

            const fullRoute = {
                'type': 'Feature',
                'geometry': {
                    'type': 'LineString',
                    'coordinates': coordinates
                }
            };

            map.on('load', () => {
                map.addSource('fullRoute', {
                    'type': 'geojson',
                    'data': fullRoute
                });

                map.addLayer({
                    'id': 'fullRoute',
                    'type': 'line',
                    'source': 'fullRoute',
                    'layout': {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    'paint': {
                        'line-color': '#1db7dd',
                        'line-width': 4
                    }
                });

                if (tripData.trip.currentLocation) {
                    const currentLocation = [tripData.trip.currentLocation.longitude, tripData.trip.currentLocation.latitude];
                    marker = new mapboxgl.Marker({color: "red"})
                        .setLngLat(currentLocation)
                        .addTo(map);
                } else {
                    console.warn("Aktuelle Position nicht verfügbar, Marker wird nicht gesetzt.");
                }

                const bounds = coordinates.reduce(function (bounds, coord) {
                    return bounds.extend(coord);
                }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));

                map.fitBounds(bounds, {
                    padding: {top: 50, bottom: 50, left: 50, right: 50}
                });

                if (tripData.trip.currentLocation) {
                    intervalId = setInterval(() => updateCurrentPosition(tripId, profile), 10000);
                }
            });
        } else {
            console.error("Keine gültigen Polyline-Daten gefunden");
        }
    }

    // Funktion zum Abrufen und Anzeigen der Daten
    // Funktion zum Abrufen und Anzeigen der Daten
    async function fetchAndDisplayData() {
        const currentUrl = window.location.href;

        const tripId = decodeURIComponent(getParameterByName('tripId', currentUrl));
        const stationId = getParameterByName('stationID', currentUrl);

        if (tripId !== currentTripId) {
            // Fehlercache für den neuen Trip initialisieren
            profileFailureCache = {
                'db': false,
                'oebb': false
            };
            currentTripId = tripId;
        }

        let data;

        // Prüfe, welche Profile zuvor fehlgeschlagen sind (für diesen Trip)
        const oebbFailedPreviously = profileFailureCache['oebb'] === true;
        const dbFailedPreviously = profileFailureCache['db'] === true;

        // Zuerst die Trip-Daten abrufen
        if (!oebbFailedPreviously) {
            try {
                // Versuche, die Daten über das ÖBB-Profil abzurufen
                let apiUrl = `https://data.cuzimmartin.dev/oebb-trip?tripId=${encodeURIComponent(tripId)}`;
                let response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error('Request failed');
                }
                data = await response.json();

                if (!data.trip) {
                    throw new Error('Keine Daten für diese Reise gefunden.');
                }

                profileUsed = 'oebb';
            } catch (error) {
                console.warn('Problem mit der ÖBB API, markiere als fehlgeschlagen.', error);
                // Markiere ÖBB als fehlgeschlagen
                profileFailureCache['oebb'] = true;
            }
        }

        if (!data && !dbFailedPreviously) {
            try {
                // Fallback auf das DB-Profil
                let apiUrl = `https://data.cuzimmartin.dev/trip?tripId=${encodeURIComponent(tripId)}`;
                let response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error('Request failed');
                }
                data = await response.json();

                if (!data.trip) {
                    throw new Error('Keine Daten für diese Reise gefunden.');
                }

                profileUsed = 'db';
            } catch (secondError) {
                console.warn('Problem mit der DB API, markiere als fehlgeschlagen.', secondError);
                // Markiere DB als fehlgeschlagen
                profileFailureCache['db'] = true;
            }
        }

        if (!data) {
            // Beide Profile haben keine Daten geliefert
            console.error('Fehler beim Abrufen der Trip-Daten mit beiden Profilen.');
            const statusElement = document.getElementById('tripStatus');
            document.getElementById('body').innerHTML= `
                <nav id="navbar">
                    <div class="tabs"><span class="active">&nbsp;Zuginformationen&nbsp;</span></div>
                    <div class="iconbar bigonly"><a href="#" onclick="history.go(-1)">Schließen</a></div>
                    <div class="iconbar"><a href="#" onclick="history.go(-1)"><img src="./assets/icons/close.svg" class="mediumicon"></a></div>
                </nav>

                <center>
                <br><br>
                <h1>⛓️‍💥</h1>
                <h3>Fehler beim Abrufen der Daten</h3>

                <p>Dieser Link ist ungültig oder deine Internet-Verbindung wurde unterbrochen.</p>

                <br>

                <div onClick=\"history.go(0)\" class="button reload">Erneut laden</div>

            `;
            return;
        }

        // Erfolgreiches Profil zurücksetzen
        profileFailureCache[profileUsed] = false;

        // Bestimme die Profile basierend auf den Trip-Daten
        const {mainProfile, fallbackProfile} = determineProfiles(data.trip);

        // Funktion zur Aktualisierung des Zugstatus
        function updateTrainStatus(trip) {
            let currentTime = new Date();
            let departureTime = trip.departure ? new Date(trip.departure) : null;
            let arrivalTime = trip.arrival ? new Date(trip.arrival) : null;

            const statusElement = document.getElementById('tripStatus');

            // Funktion zur Formatierung der Zeitangabe
            function formatTimeDifference(timeDiffMillis) {
                const totalMinutes = Math.round(timeDiffMillis / 60000);
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;

                let timeString = '';
                if (hours > 0) {
                    timeString = `${hours} Stunde${hours > 1 ? 'n' : ''}`;
                    if (minutes > 0) {
                        timeString += ` und ${minutes} Minute${minutes !== 1 ? 'n' : ''}`;
                    }
                } else {
                    timeString = `${minutes} Minute${minutes !== 1 ? 'n' : ''}`;
                }

                return timeString;
            }

            // Hilfsfunktion zur Generierung des Plattform-Strings
            function getPlatformInfo(platform) {
                return platform ? `auf Gleis ${platform}` : 'ohne festgelegtes Gleis';
            }

            // Prüfen, ob der gesamte Zug storniert wurde
            const isTripCancelled = trip.cancelled === true;

            // Prüfen, ob alle Stopovers storniert wurden
            const allStopoversCancelled = trip.stopovers.every(stop => stop.cancelled === true);

            // Wenn der Zug vollständig storniert wurde
            if (isTripCancelled && allStopoversCancelled) {
                statusElement.textContent = `Der Zug ${trip.line.name} ist vollständig ausgefallen.`;
                return;
            }

            // Wenn der Zug teilweise storniert wurde
            const cancelledStopovers = trip.stopovers.filter(stop => stop.cancelled === true);
            const activeStopovers = trip.stopovers.filter(stop => !stop.cancelled);

            // Funktion zum Finden des nächsten aktiven Stopovers
            function findNextActiveStopover() {
                for (let i = 0; i < activeStopovers.length; i++) {
                    const stop = activeStopovers[i];
                    const plannedDeparture = stop.plannedDeparture ? new Date(stop.plannedDeparture) : null;
                    const actualDeparture = stop.departure ? new Date(stop.departure) : null;

                    if ((plannedDeparture && plannedDeparture > currentTime) || (actualDeparture && actualDeparture > currentTime)) {
                        return stop;
                    }
                }
                return null;
            }

            // Wenn der Zug noch nicht abgefahren ist
            if (departureTime && currentTime < departureTime && !trip.origin.cancelled) {
                const timeUntilDeparture = departureTime - currentTime;
                const timeString = formatTimeDifference(timeUntilDeparture);

                const platformInfo = getPlatformInfo(trip.departurePlatform || trip.plannedDeparturePlatform);

                statusElement.textContent = `Der Zug fährt in ${timeString} von 🔻 ${trip.origin.name} ${platformInfo} ab.`;
                return;
            }

            // Wenn der Zug bereits abgefahren ist oder der Abfahrtsbahnhof storniert wurde
            let nextStop = findNextActiveStopover();

            if (nextStop) {
                const arrivalTimeAtNextStop = nextStop.arrival ? new Date(nextStop.arrival) : new Date(nextStop.plannedArrival);
                const timeUntilNextStop = arrivalTimeAtNextStop - currentTime;
                const timeString = formatTimeDifference(timeUntilNextStop);

                const platformInfoArrival = getPlatformInfo(nextStop.arrivalPlatform || nextStop.plannedArrivalPlatform);
                const platformInfoDeparture = getPlatformInfo(nextStop.departurePlatform || nextStop.plannedDeparturePlatform);

                if (timeUntilNextStop > 0) {
                    // Zug erreicht bald den nächsten Halt
                    statusElement.textContent = `Der Zug erreicht in ${timeString} 🔻 ${nextStop.stop.name} ${platformInfoArrival}.`;
                } else {
                    // Zug ist bereits am nächsten Halt angekommen
                    const departureTimeAtNextStop = nextStop.departure ? new Date(nextStop.departure) : new Date(nextStop.plannedDeparture);
                    const timeUntilDeparture = departureTimeAtNextStop - currentTime;

                    if (timeUntilDeparture > 0) {
                        const departureTimeString = formatTimeDifference(timeUntilDeparture);

                        statusElement.textContent = `Der Zug steht aktuell in 🔻 ${nextStop.stop.name} und fährt in ${departureTimeString} ${platformInfoDeparture} ab.`;
                    } else {
                        statusElement.textContent = `Der Zug hat 🔻 ${nextStop.stop.name} gerade verlassen und ist auf dem Weg zum nächsten Halt.`;
                    }
                }
            } else {
                // Wenn kein weiterer aktiver Halt mehr bevorsteht
                if (arrivalTime && currentTime >= arrivalTime && !trip.destination.cancelled) {
                    statusElement.textContent = `Der Zug hat sein Ziel 🔻 ${trip.destination.name} erreicht.`;
                } else if (trip.destination.cancelled) {
                    statusElement.textContent = `Der Zug endet vorzeitig und erreicht nicht sein geplantes Ziel.`;
                } else {
                    const timeUntilArrival = arrivalTime ? arrivalTime - currentTime : null;
                    const timeString = timeUntilArrival ? formatTimeDifference(timeUntilArrival) : 'unbekannter Zeit';

                    const platformInfo = getPlatformInfo(trip.arrivalPlatform || trip.plannedArrivalPlatform);

                    statusElement.textContent = `Der Zug ist auf dem Weg zu seinem Endziel 🔻 ${trip.destination.name} und wird in ${timeString} ${platformInfo} ankommen.`;
                }
            }

            // Hinweis auf ausgefallene Halte
            if (cancelledStopovers.length > 0) {
                const cancelledStopsNames = cancelledStopovers.map(stop => stop.stop.name).join(', ');
                statusElement.textContent += `\nDie folgenden Halte entfallen: ${cancelledStopsNames}.`;
            }
        }

        if ((data.trip.line.productName === 'ICE') || (data.trip.line.productName === 'IC')) {
            console.log('Its Fernzug!')
            document.getElementById('comfortbutton').classList.remove('hidden');
        }

        // Titel und Details setzen
        document.getElementById('trainTitle').innerHTML = `${data.trip.line.fahrtNr}`;

        var lineName = data.trip.line.name.split('(')[0];
        document.getElementById('linebadge').innerHTML = `${lineName}`;

        document.getElementById('title').textContent = `${data.trip.line.productName} ${data.trip.line.fahrtNr} 🡺 ${data.trip.destination.name}`;

        // Dauer berechnen
        const departureTime = new Date(data.trip.plannedDeparture);


        // Datum setzen
        const tripDate = departureTime.toLocaleDateString('de-DE', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
        document.getElementById('trip-date').innerHTML = tripDate;

        // Ursprungsstation und Zielstation setzen
        document.getElementById('originStation').textContent = data.trip.origin.name;

        document.getElementById('destinationStation').textContent = data.trip.destination.name;

        document.getElementById('mapHeader').innerHTML = `${lineName} -> ${data.trip.destination.name}`;

// Funktion zur Bestimmung des Haltestellenstatus
        function getStopStatus(stop, currentTime, isLastStop) {
            if (stop.cancelled) {
                console.log(`Haltestelle ${stop.stop.name} ist storniert.`);
                return 'cancelled';
            }

            const plannedArrival = stop.plannedArrival ? new Date(stop.plannedArrival) : null;
            const actualArrival = stop.arrival ? new Date(stop.arrival) : null;
            const plannedDeparture = stop.plannedDeparture ? new Date(stop.plannedDeparture) : null;
            const actualDeparture = stop.departure ? new Date(stop.departure) : null;

            const arrivalTime = actualArrival || plannedArrival;
            const departureTime = actualDeparture || plannedDeparture;

            console.log(`Haltestelle: ${stop.stop.name}`);
            console.log(`Ankunftszeit: ${arrivalTime}`);
            console.log(`Abfahrtszeit: ${departureTime}`);
            console.log(`Aktuelle Zeit: ${currentTime}`);

            // Wenn es sich um die Endhaltestelle handelt und die Ankunftszeit vergangen ist, setze den Status auf 'past'
            if (isLastStop && arrivalTime && arrivalTime < currentTime) {
                console.log(`Status: past (Endhaltestelle)`);
                return 'past';
            }

            if (departureTime && departureTime < currentTime) {
                console.log(`Status: past`);
                return 'past';
            } else if (!stop.nextToCurrent && arrivalTime && arrivalTime > currentTime) {
                console.log(`Status: future`);
                return 'future';
            } else {
                console.log(`Status: unknown`);
                return 'unknown';
            }
        }

// Haltestellen dynamisch hinzufügen
        const stopoversContainer = document.querySelector('.trip-stopovers');
        stopoversContainer.innerHTML = '';

        const currentTime = new Date(); // Aktuelle Zeit

        let currentStopFound = false;

        data.trip.stopovers.forEach((stop, index) => {
            const stopElement = document.createElement('div');
            stopElement.classList.add('trip-stopover');

            const isLastStop = index === data.trip.stopovers.length - 1;
            let stopStatus = getStopStatus(stop, currentTime, isLastStop);

            if (!currentStopFound && stopStatus === 'future') {
                // Setze die erste zukünftige Haltestelle als 'current'
                stopStatus = 'current';
                

                // Berechne den Fortschrittsprozentsatz basierend auf der Abfahrtszeit der vorherigen Haltestelle
                // Falls es keine vorherige Haltestelle gibt, setze den Fortschritt auf 0%
                let progressPercentage = 0;

                if (index > 0) {
                    const previousStop = data.trip.stopovers[index - 1];
                    const previousDepartureTime = previousStop.departure ? new Date(previousStop.departure) : new Date(previousStop.plannedDeparture);
                    const arrivalTime = stop.arrival ? new Date(stop.arrival) : new Date(stop.plannedArrival);
                    const departureTime = stop.departure ? new Date(stop.departure) : new Date(stop.plannedDeparture);

                    const totalTime = arrivalTime - previousDepartureTime;
                    const timePassed = currentTime - previousDepartureTime;

                    progressPercentage = (timePassed / totalTime) * 100;
                    progressPercentage = Math.min(Math.max(progressPercentage, 0), 100); // Begrenze zwischen 0% und 100%
                    console.log(`Fortschritt für ${stop.stop.name}: ${progressPercentage}%`);
                }

                // Setze die CSS-Variable mit dem Fortschrittsprozentsatz
                stopElement.style.setProperty('--progress-percentage', `${progressPercentage}%`);
                stopElement.style.setProperty('--progress-px', `${20 / 100 * progressPercentage - 10}px`);
                stopElement.innerHTML = `
                <picture>
                    <source srcset="./assets/icons/train-top-dark.svg" media="(prefers-color-scheme: dark)">
                    <source srcset="./assets/icons/train-top.svg" media="(prefers-color-scheme: light)">
                    <img src="./assets/icons/train-top.svg" alt="Location" class="trainposition">
                </picture>
                `;

            }

            // Füge eine Klasse basierend auf dem Status hinzu
            stopElement.classList.add(`stop-${stopStatus}`);
            

            // Generiere den Inhalt der Haltestelle
            if (stop.cancelled) {
                stopElement.innerHTML += `
            
            <div class="trip-stop-time">
                <div class="trip-delay" style="font-size: 16px">Entfällt</div>
            </div>
            <div class="trip-stop-info">
                <span class="trip-stop-name">${stop.stop.name}</span>
            </div>
            <div class="connection-cell">
                &nbsp;
            </div>
        `;
            } else if (stopStatus === 'current') {

                currentStopFound = true;

                const plannedArrivalTime = stop.plannedArrival ? new Date(stop.plannedArrival).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const actualArrivalTime = stop.arrival ? new Date(stop.arrival).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const plannedDepartureTime = stop.plannedDeparture ? new Date(stop.plannedDeparture).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const actualDepartureTime = stop.departure ? new Date(stop.departure).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';

                const arrivalTimeDisplay = plannedArrivalTime === actualArrivalTime || !actualArrivalTime ? plannedArrivalTime : `<s class="disabled">${plannedArrivalTime}</s> <span>${actualArrivalTime}</span>`;
                const departureTimeDisplay = plannedDepartureTime === actualDepartureTime || !actualDepartureTime ? plannedDepartureTime : `<s class="disabled">${plannedDepartureTime}</s> <span>${actualDepartureTime}</span>`;

                let stopname = stop.stop.name;
                if (stationId === stop.stop.id) {
                    stopElement.classList.add('marked-stopover');
                }

                stopElement.innerHTML += `
                
            <div class="trip-stop-time">
                <div>${arrivalTimeDisplay}</div>
                <div>${departureTimeDisplay}</div>
            </div>
            <div class="trip-stop-info">
                <span class="trip-stop-name">${stopname}</span>
                <span class="trip-platform">${(stop.arrivalPlatform || stop.departurePlatform) ? `Gl<span class="bigonly">eis</span> ${stop.arrivalPlatform || stop.departurePlatform}` : '-'}</span>
            </div>
            <div class="connection-cell">
                ${stop.arrival !== null ? `<a href="connections.html?stop=${stop.stop.location.id}&tripID=${encodeURIComponent(tripId)}">&nbsp;<img src="./assets/icons/connectingTrain.svg"></a>` : '&nbsp;<img src="./assets/icons/placeholder.svg">'}
            </div>
        `;


            } else {
                const plannedArrivalTime = stop.plannedArrival ? new Date(stop.plannedArrival).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const actualArrivalTime = stop.arrival ? new Date(stop.arrival).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const plannedDepartureTime = stop.plannedDeparture ? new Date(stop.plannedDeparture).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const actualDepartureTime = stop.departure ? new Date(stop.departure).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';

                const arrivalTimeDisplay = plannedArrivalTime === actualArrivalTime || !actualArrivalTime ? plannedArrivalTime : `<s class="disabled">${plannedArrivalTime}</s> <span>${actualArrivalTime}</span>`;
                const departureTimeDisplay = plannedDepartureTime === actualDepartureTime || !actualDepartureTime ? plannedDepartureTime : `<s class="disabled">${plannedDepartureTime}</s> <span>${actualDepartureTime}</span>`;

                let stopname = stop.stop.name;
                if (stationId === stop.stop.id) {
                    stopElement.classList.add('marked-stopover');
                }

                stopElement.innerHTML += `
                
            <div class="trip-stop-time">
                <div>${arrivalTimeDisplay}</div>
                <div>${departureTimeDisplay}</div>
            </div>
            <div class="trip-stop-info">
                <span class="trip-stop-name">${stopname}</span>
                <span class="trip-platform">${(stop.arrivalPlatform || stop.departurePlatform) ? `Gl<span class="bigonly">eis</span> ${stop.arrivalPlatform || stop.departurePlatform}` : '-'}</span>
            </div>
            <div class="connection-cell">
                ${stop.arrival !== null ? `<a href="connections.html?stop=${stop.stop.location.id}&tripID=${encodeURIComponent(tripId)}">&nbsp;<img src="./assets/icons/connectingTrain.svg"></a>` : '&nbsp;<img src="./assets/icons/placeholder.svg">'}
            </div>
        `;
            }

            stopoversContainer.appendChild(stopElement);
        });


        // Wagenreihungsbutton
        var wagonorderbutton = document.getElementById('wagonorderbutton');

        var test = '2';
        // Setze das href-Attribut

        const tripdepartureTime = new Date(new URLSearchParams(window.location.search).get('departureTime')).toISOString();

        console.log(tripdepartureTime);
        ;
        if ((stationId === null) || tripdepartureTime === null) {
            var choosenstation = data.trip.stopovers[0].stop.id;
            const tripdepartureTime = data.trip.stopovers[0].plannedDeparture;
        } else {
            var choosenstation = stationId;
            const tripdepartureTime = new URLSearchParams(window.location.search).get('departureTime');
        }


        if (wagonorderbutton) {
            wagonorderbutton.href = `wagonorder.html?trainnumber=${data.trip.line.fahrtNr}&station=${choosenstation}&producttype=${data.trip.line.productName}&departure=${tripdepartureTime}`;
        }

        // Funktion zum Entfernen von HTML-Tags aus Text (ohne Veränderung der Groß-/Kleinschreibung)
        function sanitizeText(text) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;
            return tempDiv.textContent || tempDiv.innerText || '';
        }

        // Funktion zum Entfernen von HTML-Tags und Normalisieren des Textes für Vergleichszwecke
        function sanitizeAndNormalizeText(text) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;
            let sanitizedText = tempDiv.textContent || tempDiv.innerText || '';
            // Konvertiere zu Kleinbuchstaben und entferne führende/trailing Leerzeichen
            sanitizedText = sanitizedText.toLowerCase().trim();
            // Ersetze mehrere Leerzeichen durch ein einzelnes
            sanitizedText = sanitizedText.replace(/\s+/g, ' ');
            // Optional: Ersetze Zahlen durch Platzhalter, um ähnliche Warnungen zu erkennen
            sanitizedText = sanitizedText.replace(/\d+/g, '#');
            return sanitizedText;
        }


        // Warnungen dynamisch hinzufügen
        const warningsList = document.getElementById('remarksTable');
        warningsList.innerHTML = '';

        const warningCounterElement = document.getElementById('trip-warning-counter-button');

        // Sammle die Remarks der Station
        let stationRemarks = [];
        if (stationId) {
            const stationStopover = data.trip.stopovers.find(stopover => stopover.stop.id === stationId);
            if (stationStopover && stationStopover.remarks && stationStopover.remarks.length > 0) {
                stationRemarks = stationStopover.remarks;
            }
        }

        // Sammle die Remarks des Trips
        const tripRemarks = data.trip.remarks || [];

        // Kombiniere die Remarks, wobei die der Station zuerst kommen
        const combinedRemarks = [...stationRemarks, ...tripRemarks];

        if (combinedRemarks.length > 0) {
            const uniqueMessages = new Set();
            const uniqueRemarks = [];

            combinedRemarks.forEach(remark => {
                const normalizedText = sanitizeAndNormalizeText(remark.text);
                // Check ob remark.code definiert ist
                let code = 'default';
                if (remark.code) {
                    code = sanitizeText(remark.code.replace(/\./g, ''));
                }
                if (!uniqueMessages.has(normalizedText)) {
                    uniqueMessages.add(normalizedText);
                    uniqueRemarks.push({...remark, code});
                }
            });

            const warningCount = uniqueRemarks.length;

            // Aktualisiere den Warnungszähler oben
            warningCounterElement.innerHTML = `&nbsp;${warningCount}&nbsp;`;

            const WarningHeaderItem = document.createElement('tr');
            WarningHeaderItem.innerHTML = `<td colspan="2"><h3><span class=\"pill\">&nbsp;&nbsp;${warningCount}&nbsp;&nbsp;</span> aktuelle Informationen:</h3></td>`;
            warningsList.appendChild(WarningHeaderItem);

            uniqueRemarks.forEach(remark => {
                const warningItem = document.createElement('tr');
                const code = remark.code || 'default';
                warningItem.innerHTML += (`<td class="clear"><img src="./assets/icons/remark${code}.svg" class="serviceicon"></td><td class="clear wide">${sanitizeText(remark.text)}</td>`);
                warningsList.appendChild(warningItem);
            });
        } else {
            // Aktualisiere den Warnungszähler oben
            warningCounterElement.innerHTML = '&nbsp;Keine&nbsp;';

            const WarningHeaderItem = document.createElement('div');
            WarningHeaderItem.classList.add('trip-warning-item');
            WarningHeaderItem.textContent = 'Keine Warnungen vorhanden.';
            warningsList.appendChild(WarningHeaderItem);
        }



        // Dynamischen Status des Zuges setzen
        updateTrainStatus(data.trip);

        // Header Farbe
        const badgeClassProductName = encodeURIComponent(data.trip.line.productName);
        const badgeClassProduct = encodeURIComponent(data.trip.line.product);
        const badgeClassLineOperator = encodeURIComponent(lineName.replace(/\s+/g, '')) + encodeURIComponent(data.trip.line.operator.id);
        const badgeClassOperator = encodeURIComponent(data.trip.line.operator.id);
        const tripID = encodeURIComponent(data.trip.id);

        document.getElementById('bigheaderbox').classList.add(badgeClassProductName);
        document.getElementById('bigheaderbox').classList.add(badgeClassProduct);
        document.getElementById('bigheaderbox').classList.add(badgeClassLineOperator);
        document.getElementById('bigheaderbox').classList.add(badgeClassOperator);

        document.getElementById('linebadge').classList.add(badgeClassProductName);
        document.getElementById('linebadge').classList.add(badgeClassProduct);
        document.getElementById('linebadge').classList.add(badgeClassLineOperator);
        document.getElementById('linebadge').classList.add(badgeClassOperator);

        let $number = encodeURIComponent(data.trip.id);

        // Funktion, um ein Cookie zu setzen
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/";
        }

        // Funktion, um ein Cookie abzurufen
        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        // Funktion beim Klick auf das Div
        document.getElementById('myDiv').addEventListener('click', function () {
            // Setze das Cookie
            setCookie('pinnedjourney', $number, 7); // Cookie für 7 Tage speichern
            document.getElementById("pinIt").textContent = "Angeheftet";
            document.getElementById("addtrainIcon").src = "./assets/icons/addedtrain.svg";

            // Logge den Cookie-Wert zur Konsole
            console.log('Cookie-Wert:', cookieValue);
        });

        // Rufe das Cookie ab
        const cookieValue = getCookie('pinnedjourney');

        const activeValue = `${encodeURIComponent(tripId)}`;


        if (cookieValue === activeValue) {
            console.log('It is pinned Journey');
            document.getElementById("pinIt").textContent = "Angeheftet";
            document.getElementById("addtrainIcon").src = "./assets/icons/addedtrain.svg";

        } else {
            console.log('It is not pinned Journey');
        }

        // Datenanbieter-Logo aktualisieren
        const dataProviderLogo = document.querySelector('.trip-logo');
        if (profileUsed === 'oebb') {
            dataProviderLogo.src = "https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Logo_%C3%96BB.svg/2560px-Logo_%C3%96BB.svg.png";
            dataProviderLogo.alt = "ÖBB Logo";
        } else if (profileUsed === 'db') {
            dataProviderLogo.src = "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/Deutsche_Bahn_AG-Logo.svg/512px-Deutsche_Bahn_AG-Logo.svg.png";
            dataProviderLogo.alt = "DB Logo";
        }

        // Initialisiere die Karte mit dem verwendeten Profil
        if (document.getElementById("mapModal").style.display === "block") {
            initMap(profileUsed);
        }
    }

    // Event-Handler für das Öffnen und Schließen des Modals
    document.addEventListener('DOMContentLoaded', function () {
        const modal = document.getElementById("mapModal");
        const btn = document.getElementById("openMapBtn");
        const closeBtn = document.getElementsByClassName("close")[0];


        btn.onclick = function () {
            modal.style.display = "block";
            setTimeout(() => {
                if (!map) {
                    initMap(profileUsed);
                } else {
                    map.resize();
                }
            }, 300);
        };

        closeBtn.onclick = function () {
            modal.style.display = "none";
            clearInterval(intervalId); // Stoppe die regelmäßige Positionsabfrage, wenn das Modal geschlossen wird
        };

        window.onclick = function (event) {
            if (event.target == modal) {
                modal.style.display = "none";
                clearInterval(intervalId); // Stoppe die regelmäßige Positionsabfrage, wenn das Modal geschlossen wird
            }
        };

        // Rufe fetchAndDisplayData auf
        fetchAndDisplayData();

        // Alle 30 Sekunden die Daten aktualisieren
        setInterval(fetchAndDisplayData, 30000); // 30 Sekunden in Millisekunden
    });

    fetchAndDisplayData();

</script>
</body>
</html>